#include <stdio.h>
#include <math.h>

#include "hardware/clocks.h"
#include "hardware/dma.h"
#include "pico/stdlib.h"
#include "i2s.pio.h"

#define LED_PIN (PICO_DEFAULT_LED_PIN)

// DMA stuff
// The *2 accounts for left/right
#define AUDIO_BUFFER_SIZE (32 * 2)
// Here is where the actual audio data gets written
// The *2 accounts for the fact that we are double-buffering.
static __attribute__((aligned(8))) uint32_t audio_buffer[AUDIO_BUFFER_SIZE * 2];
// Here is where the buffer addresses are stored to control DMA
// The *2 accounts for the fact that we are double-buffering.
static __attribute__((aligned(8))) uint32_t* addr_buffer[2];

static uint dma_ch_in_ctrl = 0;
static uint dma_ch_in_data = 0;

static volatile uint32_t dma_counter_0 = 0;

#define AN_BUFFER_SIZE (256)

static float an_buffer_l[AN_BUFFER_SIZE];
static float an_buffer_r[AN_BUFFER_SIZE];
static uint an_buffer_ptr = 0;

static void dma_in_handler() {   

    dma_counter_0++;

    // Figure out which part of the double-buffer we just finished
    // loading into.  Notice: the pointer is signed.
    int32_t* audio_data = 0;
    if (dma_hw->ch[dma_ch_in_data].write_addr == (uint32_t)audio_buffer) {
        audio_data = audio_buffer;
    } else {
        audio_data = &(audio_buffer[AUDIO_BUFFER_SIZE]);

    }
    // Move into analysis buffer
    for (int i = 0; i < AUDIO_BUFFER_SIZE; i += 2) {
        // The 24-bit value is left-justified in the 32-bit word, 
        // so we need to shift right 8. Sign extension is automatic.
        // TODO: FIGURE OUT WHAT LEFT AND RIGHT ARE
        an_buffer_l[an_buffer_ptr] = audio_data[i] >> 8;
        an_buffer_r[an_buffer_ptr] = audio_data[i + 1] >> 8;
        // Increment and wrap
        an_buffer_ptr++;
        if (an_buffer_ptr == AN_BUFFER_SIZE) 
            an_buffer_ptr = 0;
    }
    // Clear the IRQ status
    dma_hw->ints0 = 1u << dma_ch_in_data;
}

int main(int argc, const char** argv) {


    unsigned long fs = 48000;
    unsigned long sck_mult = 384;
    unsigned long sck_freq = sck_mult * fs;
    // Pin to be allocated to I2S SCK (output to CODEC)
    // GP10 is physical pin 14
    uint sck_pin = 10;
    // Pin to be allocated to ~RST
    uint rst_pin = 5;
    // Pin to be allocated to I2S DIN (input from)
    uint din_pin = 6;
    // This was chosen because it gives an even division to 
    // sck_freq.
    //unsigned long system_clock_khz = 129600;
    // This value was chosen in order to get a multiple of 48,000
    unsigned long system_clock_khz = 125000;

    // Adjust system clock to more evenly divide the 
    // audio sampling frequency.
    set_sys_clock_khz(system_clock_khz, true);

    stdio_init_all();

    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);

    gpio_init(rst_pin);
    gpio_set_dir(rst_pin, GPIO_OUT);
    gpio_put(rst_pin, 1);

    // Startup ID
    sleep_ms(500);
    puts("I2S Demo");

    // Reset the CODEC
    gpio_put(rst_pin, 0);
    sleep_ms(100);
    gpio_put(rst_pin, 1);
    sleep_ms(100);

    // ----- SCK Setup ------------------------------------------------------

    // Allocate state machine
    uint sck_sm = pio_claim_unused_sm(pio0, true);
    uint sck_sm_mask = 1 << sck_sm;

    // Load PIO program into the PIO
    uint sck_program_offset = pio_add_program(pio0, &i2s_sck_program);
  
    // Setup the function select for a GPIO to use output from the given PIO 
    // instance.
    // 
    // PIO appears as an alternate function in the GPIO muxing, just like an 
    // SPI or UART. This function configures that multiplexing to connect a 
    // given PIO instance to a GPIO. Note that this is not necessary for a 
    // state machine to be able to read the input value from a GPIO, but only 
    // for it to set the output value or output enable.
    pio_gpio_init(pio0, sck_pin);

    // NOTE: The xxx_get_default_config() function is generated by the PIO
    // assembler and defined inside of the generated .h file.
    pio_sm_config sck_sm_config = 
        i2s_sck_program_get_default_config(sck_program_offset);
    // Associate pin with state machine. 
    // Because we are using the "SET" command in the PIO program
    // (and not OUT or side-set) we use the set_set function here.
    sm_config_set_set_pins(&sck_sm_config, sck_pin, 1);
    // Initialize setting and direction of the pin before SM is enabled
    uint sck_pin_mask = 1 << sck_pin;
    pio_sm_set_pins_with_mask(pio0, sck_sm, 0, sck_pin_mask);
    pio_sm_set_pindirs_with_mask(pio0, sck_sm, sck_pin_mask, sck_pin_mask);
    // Hook it all together.  (But this does not enable the SM!)
    pio_sm_init(pio0, sck_sm, sck_program_offset, &sck_sm_config);

    // Adjust state-machine clock divisor.  Remeber that we need
    // the state machine to run at 2x SCK speed since it takes two 
    // instructions to acheive one clock transition on the pin.
    //
    // NOTE: The clock divisor is in 16:8 format
    //
    // d d d d d d d d d d d d d d d d . f f f f f f f f
    //            Integer Part         |  Fraction Part
    unsigned int sck_sm_clock_d = 4;
    //unsigned int sck_sm_clock_f = 132;
    // Avoid jitter by avoiding fractional clock division.
    unsigned int sck_sm_clock_f = 0;
    // Sanity check:
    // 2 * (3 + (132/256)) = 7.03125
    // 7.03125 * 48,000 * 384 = 129,600,000
    pio_sm_set_clkdiv_int_frac(pio0, sck_sm, sck_sm_clock_d, sck_sm_clock_f);

    // ----- DIN Setup ------------------------------------------------------

    // Allocate state machine
    uint din_sm = pio_claim_unused_sm(pio0, true);
    uint din_sm_mask = 1 << din_sm;

    // Load program into the PIO
    uint din_program_offset = pio_add_program(pio0, &i2s_din_program);
  
    // Setup the function select for a GPIO to use from the given PIO 
    // instance.
    // DIN
    pio_gpio_init(pio0, din_pin);
    gpio_set_pulls(din_pin, false, false);
    gpio_set_dir(din_pin, GPIO_IN);
    // BCK
    pio_gpio_init(pio0, din_pin + 1);
    gpio_set_pulls(din_pin + 1, false, false);
    gpio_set_dir(din_pin + 1, GPIO_IN);
    // LRCK
    pio_gpio_init(pio0, din_pin + 2);
    gpio_set_pulls(din_pin + 2, false, false);
    gpio_set_dir(din_pin + 2, GPIO_IN);

    // NOTE: The xxx_get_default_config() function is generated by the PIO
    // assembler and defined inside of the generated .h file.
    pio_sm_config din_sm_config = 
        i2s_din_program_get_default_config(din_program_offset);
    // Associate the input pins with state machine.  This will be 
    // relevant to the DIN pin for IN instructions and the BCK, LRCK
    // pins for WAIT instructions.
    sm_config_set_in_pins(&din_sm_config, din_pin);
    // Set the "jump pin" for the state machine. This will be the 
    // LRCK pin in this usage.
    sm_config_set_jmp_pin(&din_sm_config, din_pin + 2);
    // Configure the IN shift behavior.
    // Parameter 0: "false" means shift ISR to left on input.
    // Parameter 1: "false" means autopush is not enabled.
    // Parameter 2: "0" means threshold (in bits) before auto/conditional 
    //              push to the ISR.
    sm_config_set_in_shift(&din_sm_config, false, false, 0);
    // Merge the FIFOs since we are only doing RX.  This gives us 
    // 8 words of buffer instead of the usual 4.
    sm_config_set_fifo_join(&din_sm_config, PIO_FIFO_JOIN_RX);

    // Initialize the direction of the pins before SM is enabled
    // There are three pins in the mask here. 
    uint din_pins_mask = 0x07 << din_pin;
    // The "0" means input.
    pio_sm_set_pindirs_with_mask(pio0, din_sm, 0, din_pins_mask);

    // Hook it all together.  (But this does not enable the SM!)
    pio_sm_init(pio0, din_sm, din_program_offset, &din_sm_config);
          
    // Adjust state-machine clock divisor.  The speed is somewhat
    // arbitrary here, so long as it is fast enough to see the 
    // transitions on BCK and LRCK.  We run it at the same speed as the 
    //
    // NOTE: The clock divisor is in 16:8 format
    //
    // d d d d d d d d d d d d d d d d . f f f f f f f f
    //            Integer Part         |  Fraction Part
    //unsigned int din_sm_clock_d = 5;
    //unsigned int din_sm_clock_f = 70;
    pio_sm_set_clkdiv_int_frac(pio0, din_sm, 
        sck_sm_clock_d, sck_sm_clock_f);

    // ----- DMA setup -------------------------------------------

    // The control channel will read between these two addresses,
    // telling the data channel to write to them alternately (i.e.
    // double-buffer).
    addr_buffer[0] = audio_buffer;
    addr_buffer[1] = &(audio_buffer[AUDIO_BUFFER_SIZE]);
    
    dma_ch_in_ctrl = dma_claim_unused_channel(true);
    dma_ch_in_data = dma_claim_unused_channel(true);

    // Setup the control channel. This channel is only needed to 
    // support the double-buffering behavior. A write by the control
    // channel will trigger the data channel to wake up and 
    // start to move data out of the PIO RX FIFO.
    dma_channel_config cfg = dma_channel_get_default_config(dma_ch_in_ctrl);
    // The control channel needs to step across the addresses of 
    // the various buffers.
    channel_config_set_read_increment(&cfg, true);
    // But always writing into the same location
    channel_config_set_write_increment(&cfg, false);
    // Sanity check before we start making assumptions about the
    // transfer size.
    assert(sizeof(uint32_t*) == 4);
    // Configure how many bits are involved in the address rotation.
    // 3 bits are used because we are wrapping through a total of 8 
    // bytes (two 4-byte addresses).  
    // The "false" means the read side.
    channel_config_set_ring(&cfg, false, 3);
    // Each address is 32-bits, so that's what we need to transfer 
    // each time.
    channel_config_set_transfer_data_size(&cfg, DMA_SIZE_32);
    dma_channel_configure(dma_ch_in_ctrl, &cfg, 
        // Here is where we write to (the data channel)
        // NOTE: dma_hw is a global variable from the PICO SDK
        &dma_hw->ch[dma_ch_in_data].al2_write_addr_trig,
        // Here is where we read from (the address buffer area)
        addr_buffer, 
        // Number of transfers to perform before waiting.
        1, 
        // false means don't start yet
        false);

    // Setup the data channel.
    cfg = dma_channel_get_default_config(dma_ch_in_data);
    // No increment required because we are always reading from the 
    // PIO RX FIFO every time.
    channel_config_set_read_increment(&cfg, false);
    // We need to increment the write to move across the buffer
    channel_config_set_write_increment(&cfg, true);
    // Set size of each transfer (one audio word)
    channel_config_set_transfer_data_size(&cfg, DMA_SIZE_32);
    // We trigger the control channel once the data transfer is done
    channel_config_set_chain_to(&cfg, dma_ch_in_ctrl);
    // Attach the DMA channel to the RX DREQ of the PIO state machine. 
    // The "false" below indicates RX.
    // This is the "magic" that connects the PIO SM to the DMA.
    channel_config_set_dreq(&cfg, pio_get_dreq(pio0, din_sm, false));
    dma_channel_configure(dma_ch_in_data, &cfg,
        // 0 means that the target will be set by the control channel
        0, 
        // The memory-mapped location of the RX FIFO of the PIO state
        // machine used for receiving data
        // This is the "magic" that connects the PIO SM to the DMA.
        &pio0->rxf[din_sm],
        // Number of transfers (each is 32 bits)
        AUDIO_BUFFER_SIZE,
        // Don't start yet
        false);

    // Enable interrupt when DMA data transfer completes
    dma_channel_set_irq0_enabled(dma_ch_in_data, true);
    // Bind to the interrupt handler and enable
    irq_set_exclusive_handler(DMA_IRQ_0, dma_in_handler);
    irq_set_enabled(DMA_IRQ_0, true);

    // Start DMA action on the control side.  This will trigger
    // the data DMA channel in turn.
    dma_channel_start(dma_ch_in_ctrl);

    // Final enable of the two SMs
    pio_enable_sm_mask_in_sync(pio0, sck_sm_mask | din_sm_mask);

    // Endless loop
    while (true) {
        gpio_put(LED_PIN, 1);
        sleep_ms(500);
        gpio_put(LED_PIN, 0);
        sleep_ms(500);

        // Analyze the buffers
        float mag_l = 0;
        float mag_r = 0;
        for (int i = 0; i < AN_BUFFER_SIZE; i++) {
            mag_l += fabs(an_buffer_l[i]);
            mag_r += fabs(an_buffer_r[i]);
        }
        mag_l /= (float)AN_BUFFER_SIZE;
        mag_r /= (float)AN_BUFFER_SIZE;

        printf("dma_counter_0=%d  l=%f r=%f\n", dma_counter_0, mag_l, mag_r);
    }

    return 0;
}